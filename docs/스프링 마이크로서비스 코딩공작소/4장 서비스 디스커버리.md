4장. 서비스 디스커버리
===================

 * #### 서비스 디스커버리 : 분산환경에서 시스템의 물리적 위치를 찾는 것
   * #### MSA에서 서비스 디스커버리가 중요한 이유
     * 서비스 인스턴스 개수를 자유롭게 수평 확장, 축소 가능 (소비자에게 물리적 위치 노출X)
     * 비정상 인스턴스를 피해서 라우팅하므로 장애 피해 최소화(애플리케이션 회복성 향상)

---       

### 4.1 서비스 위치 찾기(전통적인 방식)
 <p align="center"><img src="https://user-images.githubusercontent.com/22882450/150636208-c44a1def-8c03-4dcf-a2bc-4ca44e2a383b.png" alt="그림 4-1 DNS와 로드 밸런서를 사용하는 전통적 서비스 위치 확인 모델" width="70%" height="70%"></p>

* DNS와 로드 밸런서를 사용한 서비스 위치 확인 모델은 회사 내에서 정적 서버 그룹에서 실행되는 소수의 서비스에는 잘 동작
* 클라우드 기반의 MSA에서 부적합한 이유
  * <b>단일장애지점</b> : 로드밸런서가 전체 인프라스트럭처의 단일장애지점되어 전체 서비스 다운됨
  * <b>수평 확장의 제약성</b> : 로드밸런서 하나의 서버만 사용(hot-swap방식)하여 하드웨어의 제약으로 부하 분산을 위한 확장 능력 제한
  * <b>정적관리</b> : 로드밸런서는 서비스를 신속한 등록/취소 불가능(공급업체 독점 api 사용하여 라우팅 테이블에 저장)
  * <b>복잡성</b> : 아웃바운드 시 물리적인 서비스 매핑 정보가 필요하며 해당 정보 수동 정의 및 배포하여 운영 복잡성 가중

4.1 결론 
> 대용량 트랜잭션과 중복성을 처리하는 *<U>클라우드 환경에서는 중앙집중식 인프라스트럭처는 효율적으로 확장되지 않고 비용 효율도 낮아서 결국 제대로 동작 못함</U>*

---
### 4.2 클라우드에서 서비스 디스커버리

* #### 서비스 디스커버리 메커니즘
  * **고가용성** : 서비스 디스커버리 검색정보를 클러스터 여러 노드가 공유(한 노드 죽으면 다른 노드 인계)
  * **피어 투 피어** : 클러스터 각 노드는 서비스 상태를 P2P방식 공유
  * **부하분산** : 동적으로 모든 서비스 인스턴스에 부하 분산(기 모델 정적/수동 관리)
  * **회복성** : 서비스 디스커버리 클라이언트는 서비스 정보를 로컬에 캐시한다.(서비스 디스커버리 비가용시 대체 가능)
  * **장애내성** : 비정상 서비스 인스턴스 탐지 및 가용 목록에서 인스턴스 제거(자동 조치)

* #### 4.2.1 서비스 디스커버리 아키텍처
  * 디스커버리 구현체 개념 네가지
    * 서비스 등록(*언제 서비스 디스커버리 에이전트에 등록?*)
    * 클라이언트가 서비스 주소 검색(*서비스 클라이언트가 어떻게 서비스 정보를 검색?*)
    * 정보 공유(*서비스 정보를 노드 간 어떻게 공유?*)
    * 상태 모니터링(*서비스가 자신의 상태정보를 에이전트에게 어떻게 전달?*)
---    
    
<p align="center"><img src="https://user-images.githubusercontent.com/22882450/150642211-30602956-66e6-4753-bdc0-9f64085210eb.png" alt="그림 4-2 서비스 인스턴스가 추가 제거될 때 서비스 디스커버리 에이전트를 업데이트하고 사용자 요청을 처리할 수 있는 상태가 된다." width="70%" height="70%"></p>

* 서비스 인스턴스 시작 시 서비스 디스커버리 인스턴스가 접근할 수 자신의 정보 등록(물리적 위치, 경로, 포트)
* P2P모델을 사용해 서비스 인스턴스 정보를 다른 디스커버리 노드에 전파
  * 전파 메커니즘 : 하드코딩 / gossip 프로토콜 / infection-style 프로토콜
* 서비스 인서턴스의 상태는 자기가 직접 디스커버리에 푸시 혹은 서비스 디스커버리가 상태 추출함.
  * 비정상 인서턴스는 가용 서비스 인스턴스 pool에서 제거
---
### 클라이언트 서비스를 발견하는 2가지 방식
1. 서비스 디스커버리 엔진에 의존 방식
2. 클라이언트 부하 분산 방식(리본)

<p align="center"><img src="https://user-images.githubusercontent.com/22882450/150642216-32e8fb0a-fb8f-45cb-9fc6-363eba6758c0.png" alt="그림 4-3 클라이언트 측 부하 분산 방식은 클라이언트가 호출할 때마다 서비스 디스커버리를 연결할 필요가 없도록 서비스 위치를 캐시한다." width="70%" height="70%"></p>

* 서비스 소비자 요청 &rarr; 서비스 디스커버리 접속 &rarr; 서비스 정보가 소비스 소비자 로컬 캐시<br/>
* 서비스 소비자는 요청이 올 때마다 캐시 위치 정보 검색 &rarr; 여러 인스턴스로 분산
* 클라이언트는 주기적으로 서비스 디스커버리에 접속해 서비스 인스턴스 캐시 '새로고침'함.(최종 일관성 유지)
  * 단 비정상 인스턴스 호출 위험성은 존재(실패 후 로컬 캐시 무효화 후 다시 새로고침)

<p align="center"><img src="https://user-images.githubusercontent.com/22882450/150642221-e1e277e7-16a7-4255-ac5b-a2c28c6f7d95.png" alt="그림 4-4 라이선싱 및 조직 서비스에 클라이언트 측 캐싱과 유레카 서버에 대한 부하를 줄이고, 유레카 서버가 가용하지 않을 때 클라이언트 안정성을 높인다." width="70%" height="70%"></p>

* 서비스 설명 : 라이선싱 서비스 호출 시 해당 조직ID에 연관된 조직 정보를 조회하기 위해 조직 서비스를 호출
  * 조직 서비스의 실제 위치는 서비스 디스커버리 레지스트리에 등록된다.
* 서비스 부트스트래핑 시점에 라이선싱 및 조직 서비스는 자신을 유레카 서비스에 등록(서비스ID, 물리적위치, 포트번호)
* 라이선싱 서비스가 조직 서비스 호출 시 리본 라이브러리를 사용해 클라이언트 측 부하 분산 기능 수행
  * *리본 라이브러리는 유레카 서비스에서 서비스 위치 조회 및 로컬 캐싱함*.
  * *주기적으로 넷플릭스 리본은 '새로고침' 한다.

---
### 4.3 스프링 유레카 서비스 구축

* 스프링 클라우드 유레카 서비스 애너테이션과 의존성 구성 적용

```xml
<dependencies>   
      <dependency>      
         <groupId>org.springframework.cloud</groupId>
         <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId> --메이븐 빌드가 유레카 라이브러리를 포함한다(이때 리본 라이브러리가 포함된다).
      </dependency>
</dependencies>
```
 * application.yml 파일의 유레카 구성 설정
```yaml
server:
    port: 8761 ----독립 실행 모드로 설정

eureka:
    client: 
        registerWithEureka: false --유레카 서비스에 (자신을) 등록하지 않는다.
        fetchRegistry: false --레지스트리 정보를 로컬에 캐싱하지 않는다.(유레카 클라이언트를 유레카에 등록할 경우 변경 필요)
    server: 
        waitTimeInMsWhenSyncEmpty: 5 --서버가 요청을 받기 전 대기할 초기 시간(기본 5분 후 서비스 공유 시작하기 때문에 local 환경에서 단축시키기 위해 사용)
    serviceUrl:
        defaultZone: http://localhost:8761
```

 * 유레카 서버 활성화하는 부트스트랩 클래스에 애너테이션 추가
```java
@SpringBootApplication
@EnableEurekaServer //스프링 서비스에서 유레카 서버 활성화
public class EurekaServerApplication{
    public static void main(String[] args){
        SpringApplication.run(EurekaServerApplication.class, args);
    }
}
```
* 이제 스프링부트를 시작하면 등록된 서비스가 없는 유레카가 실행됨 &rarr; 조직 서비스 빌드하고 유레카 서비스에 등록됨

### 4.4 스프링 유레카 서비스 등록