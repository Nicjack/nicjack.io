3장 카프카 기본 개념 설명
===================
1) 카프카 브로커는 카프카 클라이언트와 데이터를 주고받는 주체
   * #### 데이터 분산 저장이 안전하게 사용 가능한 애플리케이션임
   * #### 하나의 서버에 하나의 브로커 실행
   * #### 보통 3대 이상의 브로커를 1개의 클러스터로 운영함(저장과 복제를 위함)
2) 프로듀서가 데이터를 전달 > 브로커의 토픽의 파티션에 데이터 저장 > 컨슈머가 데이터를 요청하여 수신
   * #### 데이터는 config/server.properties의 log.dir에서 정의한 위치
   * #### 토픽이름, 파티션 번호의 조합의 디렉토리가 생성됨(파티션의 개수만큼 디렉토리 생김)
   * #### 페이지 캐쉬를 사용하여 디스크 입출력 속도를 해결(페이지 캐쉬 : OS에서 파일 입출력의 성능 향상을 위한 메모리 영역)
     * #### 한 번 읽은 파일 내용은 메모리에 저장되어 추후 다시 접근시 메모리에 접근하고 디스크를 읽지 않는 방식
     * #### 힙 메모리 사이즈를 설정할 필요 없음
3) 데이터 복제는 카프카의 장애 허용 시스템으로 동작위한 것
   * #### 클러스터의 일부 브로커가 장애가 발생해도 데이터 유실없이 안전히 사용 가능
   * #### 복제는 파티션 단위
     * #### 복제개수는 최소값은 1, 최대값은 브로커 개수만큼임
   * #### 복제된 파티션은 리더(프로듀서와 직접 통신)와 팔로워(복제)로 구성됨
     * #### 팔로워 파티션들은 리더 파티션의 오프셋을 확인하여 차이가 나는 경우 데이터를 복제함
     * #### 리더 파티션의 브로커가 장애면 팔로워 파티션 중에서 리더 지위를 넘겨 받음
     * #### 어느정도 유실이 허용 가능하면 복제개수는 1 혹은 2로 유실 허용하지 않은면 3으로 지정하여 관리 필요
4) 컨트롤러
   * #### 클러스터내 브로커 중 한대가 역할 수행
   * #### 컨트롤러는 다른 브로커들의 상태를 체크하고 클러스터에서 빠지는 경우 해당 브로커에 존재하는 리더 파티션을 재분배함
     * #### 브로커의 상태가 비정상일 때 클러스터에서 빼는 것이 중요
     * #### 자기자신이 장애가 생기면 다른 브로커가 컨트롤러 역할을 수행함
5) 데이터 삭제
   * #### 컨슈머가 데이터를 가져가더라도 토픽의 데이터는 삭제 안 됨
   * #### 컨슈머나 프로듀서가 데이터 삭제 요청을 할 수도 없음
   * #### 오직 브로커만이 데이터를 삭제할 수 있음
     * #### 로그 세그먼트라는 파일단위로 저장 및 삭제가 됨
     * #### 다수의 데이터가 들어 있어서 특정 데이터만 삭제 할 수 없음
     * #### log.segment.bytes, log.segment.ms으로 크기 설정하며 기본이 1GB(넘으면 세크면서 삭제됨)
     * #### 크기 설정을 너무 작게하면 데이터를 저장하는 동안 너무 자주 여닫음으로서 부하를 발생시킴
     * #### 세그먼트 파일 체크 간격은 log.retention.check.interval.ms
6) 컨슈머 오프셋 저장
   * #### 컨슈머 그룹은 파이션의 어느 레코드까지 가져갔는지 확인하기 위해 오프셋을 커밋한다.(_consumer_offsets토픽에 저장)
7) 코디네이터(coordinator)
    * #### 브로커 중 한 대가 코디네이터의 역할 수행
    * #### 코디네이터는 컨슈머 그룹의 상태를 체크하고 파티션을 컨슈머와 매핑하도록 분배 역할 담당
    * #### 리밸러스(rebalance) : 컨슈머가 그룹에서 빠지는 경우 맹칭되지 않는 파티션을 정상 동작 컨슈머로 할당
8) 주키퍼는 카프카의 메타데이터 관리
   * #### 어떤 보안 규칙으로 통신하는지, jmx port 상태 정보, host 정보 등이 포함
   * #### 어느 브로커가 컨트롤러인지에 관한 정보
   * #### 주키퍼 앙상발 안에 N개의 주키퍼가 포함
   * #### 한 개의 주키퍼에 다수의 카프카 클러스터 연결하여 사용됨
   * #### znode란 주키퍼에서 사용하는 데이터 자장 단위
     * #### znode간 계층구조를 가지게 되며 2개 이상의 카프카 클러스터를 구축할 때 root znode 아래 N개의 znode 생성하여 를 각 카프카 브로커 옵션으로 지정 클러스터별 독립적 사용함.
9) 토픽과 파티션
    * #### 토픽은 데이터를 구분하기 위해 사용되는 단위(최소 1개의 파티션을 소유함)
    * #### 파티션은 프로듀서가 보낸 데이터들이 저장이 되며 이 데이터들을 레코드라고 부른다.
    * #### 컨슈머 그룹으로 묶인 컨슈머들이 레코드를 병렬로 처리할 수 있게 파티션별로 매칭됨
    * #### 파티션은 큐와 유사하며 FIFO방식이지만 큐와 차이점은 큐는 데이터를 가져가면 POP처리가 되면서 삭제가 되지만 카프카는 데이터가 남게 됨
    * #### 토픽 이름은 구성원들과 잘 협의해서 정해야 좋음
10) 레코드
     * #### 타임스탬프, 메시지 키, 메시지 값, 오프셋, 헤더로 구성됨
     * #### 프로듀서가 생성한 레코드는 오프셋과 타임스탬프로 지정됨.
     * #### 브로커에 적재된 레코드는 수정할 수 없고 리텐션 기간 또는 용량에 따라서 삭제됨
     * #### 메시지키는 순서대로 처리하거나 메시지 값의 종류를 나타내기 위해 사용
     * #### 만약 메시지키가 null이면 프로듀서 기본 설정 파티셔너에 따라서 파티션에 분배됨

# 고민해볼 것 
 * #### 파티션과 큐의 차이와 왜 파티션은 데어티를 삭제하지 않는 것인지?
 * #### 레코드에 메시지키가 null 경우 파티셔너에 의한 분배 정책은 어떻게 되는 것일까?
 * #### 코디네이터가 파티션과 컨슈머의 매칭을 시켜주는 데 어떤 정책으로 하는 것일까?
 * #### 로그 세그먼트 단위로 데이터가 저장되는 데 레코들로 로그 세그먼트를 저장하지 않고 여러 레코드별로 레코드를 묶어서 저장한 이유는 무엇일까?